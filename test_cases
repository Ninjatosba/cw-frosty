// Test1
// instantiate
// //contract balance: 0

// first bond
// //amount:10 staked

// contract balance updated = 100 reward

// second bond
// //amount: 20

// third bond
// //amount: 30

//fourth bond
// //amount: 40

//every holder updates their rewards and query each holder

//check state
// holder: HolderResponse { address: "staker1", balance: Uint128(10), index: Decimal256(Uint256(10000000000000000000)), pending_rewards: Uint128(100), dec_rewards: Decimal256(Uint256(0)) }
// holder2: HolderResponse { address: "staker2", balance: Uint128(20), index: Decimal256(Uint256(10000000000000000000)), pending_rewards: Uint128(0), dec_rewards: Decimal256(Uint256(0)) }
// holder3: HolderResponse { address: "staker3", balance: Uint128(30), index: Decimal256(Uint256(10000000000000000000)), pending_rewards: Uint128(0), dec_rewards: Decimal256(Uint256(0)) }
// holder4: HolderResponse { address: "staker4", balance: Uint128(40), index: Decimal256(Uint256(10000000000000000000)), pending_rewards: Uint128(0), dec_rewards: Decimal256(Uint256(0)) }

//staker1 recieves reward
// staker1 rewards res:: Response { messages: [SubMsg { id: 0, msg: Bank(Send { to_address: "staker1", amount: [Coin { denom: "rewards", amount: Uint128(100) }] }), gas_limit: None, reply_on: Never }], attributes: [Attribute { key: "action", value: "receive_reward" }, Attribute { key: "rewards", value: "0" }, Attribute { key: "holder", value: "staker1" }, Attribute { key: "holder_balance", value: "10" }], events: [], data: None }

//check state
// state: StateResponse { global_index: Decimal256(Uint256(10000000000000000000)), total_staked: Uint128(100), prev_reward_balance: Uint128(100) }

//check staker1
// holder1: HolderResponse { address: "staker1", balance: Uint128(10), index: Decimal256(Uint256(10000000000000000000)), pending_rewards: Uint128(0), dec_rewards: Decimal256(Uint256(0)) }

//update balance to 200

//staker5 bonds

//staker6 bonds

//staker5 updates reward
//query staker5
// holder5: HolderResponse { address: "staker5", balance: Uint128(50), index: Decimal256(Uint256(11000000000000000000)), pending_rewards: Uint128(0), dec_rewards: Decimal256(Uint256(0)) }

//staker6 updates reward
//query staker6
// holder6: HolderResponse { address: "staker6", balance: Uint128(60), index: Decimal256(Uint256(11000000000000000000)), pending_rewards: Uint128(0), dec_rewards: Decimal256(Uint256(0)) }

//check state
// state: StateResponse { global_index: Decimal256(Uint256(10000000000000000000)), total_staked: Uint128(100), prev_reward_balance: Uint128(100) }

//staker2 recieves reward
// staker2 rewards res: Response { messages: [SubMsg { id: 0, msg: Bank(Send { to_address: "staker2", amount: [Coin { denom: "rewards", amount: Uint128(20) }] }), gas_limit: None, reply_on: Never }], attributes: [Attribute { key: "action", value: "receive_reward" }, Attribute { key: "rewards", value: "0" }, Attribute { key: "holder", value: "staker2" }, Attribute { key: "holder_balance", value: "20" }], events: [], data: None }

//check state
// state: StateResponse { global_index: Decimal256(Uint256(11000000000000000000)), total_staked: Uint128(210), prev_reward_balance: Uint128(200) }

//check staker2
// holder2: HolderResponse { address: "staker2", balance: Uint128(20), index: Decimal256(Uint256(11000000000000000000)), pending_rewards: Uint128(0), dec_rewards: Decimal256(Uint256(0)) }

// start: now = 01/01/2023
// end: now + 30 days
// 10 000 rewards
// remaning time: 30 days
// total staked: 30
// total weight : 1/9

// 2 days passed
// 2/30 = 0.06666666666666666666666666666667*10000/30/0,11= 200

// new reward at 15th day:
// remaning reward: 5000
// remaning time: 15 days
// desired time to end rewards : 01/03/2023
// total reward : 15 000
// remaning time : 45 days

// 17 days passed
// 2/45*15000/30/0,11 = 200

// 2 days passed
// 2/45 = 0.04444444444444444444444444444444*15000/30/0,11= 200
